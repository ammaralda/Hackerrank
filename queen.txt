 int count = 0;
    
    for(int i=1; i<=8; i++)
    {
        int locx = r_q;
        int locy = c_q;
        

        while(1)
        {
            if(i==1)
                locx = locx - 1;   
            if(i==2)
            {
                locx = locx - 1;  
                locy = locy + 1; 
            }
            if(i==3)
            {
                locy = locy + 1; 
            }  
            if(i==4)
            {
                locx = locx + 1;  
                locy = locy + 1; 
            }
            if(i==5)
            {
                locx = locx + 1;  
            }
            if(i==6)
            {
                locx = locx + 1;  
                locy = locy - 1; 
            } 
            if(i==7)
            {
                locy = locy - 1; 
            }
            if(i==8)
            {
                locx = locx - 1;  
                locy = locy - 1; 
            }
                
                
            bool stop = false;
            
            
            for(int j=0; j< obstacles.size(); j++)
                if(locx == obstacles[j][0] && locy == obstacles[j][1])
                {
                    stop = true;
                    break;
                }

            
            if(locx < 1)
                stop = true;
                
            if(locy < 1)
                stop = true;
                
            if(locx > n)
                stop = true;
                
            if(locy > n)
                stop = true;
                
            if(stop)
                break;
            
            count ++;
        }
        
        cout << "count:"<<count << endl;
        cout << "i:"<<i<< endl;  


















int queensAttack(int n, int k, int r_q, int c_q, vector<vector<int>> obstacles) {
    
    int r1= r_q - 1;
    int r2= n - r_q;

    int c1= c_q -1;
    int c2=n-c_q;

    int pd1=min(r_q - 1, c_q -1);
    int pd2=min(n - r_q, n-c_q);

    int nd1=min( r_q - 1, n-c_q);
    int nd2=min( n - r_q, c_q -1);
    

    for(int j=0; j< obstacles.size(); j++)
    {
        // Calculate row
        if(obstacles[j][1]== c_q && obstacles[j][0] < r_q )    
            if((r_q-obstacles[j][0]-1) < r1) 
                r1 =r_q-obstacles[j][0]-1;
                
        if(obstacles[j][1]== c_q && obstacles[j][0] > r_q )    
            if((obstacles[j][0]-r_q-1) < r2) 
                r2 =obstacles[j][0]-r_q-1;
        
        // Calculate col
        
        if(obstacles[j][0]== r_q && obstacles[j][1] < c_q )    
            if((c_q-obstacles[j][1]-1) < c1) 
                c1 =c_q-obstacles[j][1]-1;
                
        if(obstacles[j][0]== r_q && obstacles[j][1] > c_q )    
            if((obstacles[j][1]-c_q-1) < c2) 
                c2 =obstacles[j][1]-c_q-1;
                
                
        //Calculate diagonal1
        if(obstacles[j][1]== obstacles[j][0] + (c_q - r_q) && 
            obstacles[j][0] < r_q && obstacles[j][1] < c_q)    
            if((c_q-obstacles[j][1]-1) < pd1) 
                pd1 =c_q-obstacles[j][1]-1;
                
        if(obstacles[j][1]== obstacles[j][0] + (c_q - r_q) && 
            obstacles[j][0] > r_q && obstacles[j][1] > c_q)   
            if((obstacles[j][1]-c_q-1) < pd2) 
                pd2 = obstacles[j][1]-c_q-1;
                
        if(obstacles[j][1]== (-1*obstacles[j][0]) + (c_q + r_q) && 
            obstacles[j][0] < r_q && obstacles[j][1] > c_q)    
            if((r_q-obstacles[j][0]-1) < nd1) 
                nd1 =r_q-obstacles[j][0]-1;
                
        if(obstacles[j][1]== (-1*obstacles[j][0]) + (c_q + r_q) && 
            obstacles[j][0] > r_q && obstacles[j][1] < c_q)   
            if((obstacles[j][0]-r_q-1) < nd2) 
                nd2 =obstacles[j][0]-r_q-1;
                
    }        
    
        cout << r1 << endl;
    cout << r2 << endl;    
    cout << c1 << endl;
    cout << c2 << endl;
    cout << pd1 << endl;
    cout << pd2 << endl;
    cout << nd1 << endl;
    cout << nd2 << endl;

    
    return r1+r2+c1+c2+pd1+pd2+nd1+nd2;
}








      
        